"""
Project:     Concordia AI
Name:        ai/models.py
Author:      Ian Kollipara <ian.kollipara@cune.edu>
Date:        2025-08-14
Description: Models for AI Project
"""

from __future__ import annotations

import itertools
import typing as t

from django.contrib.auth import get_user_model
from django.contrib.auth import models as auth_models
from django.db import models
from django.utils.translation import gettext_lazy as _

from ai import llm

if t.TYPE_CHECKING:
    from django.db.models.manager import RelatedManager

UserModel = get_user_model()

# Create your models here.

### CourseBot ###


class CourseBotQuerySet(models.QuerySet["CourseBot"]):
    """Custom Queryset for CourseBot."""

    def for_name(self, name: str):
        """Filter the CourseBot down by name."""

        return self.filter(name=name)

    def for_user(self, user: UserModel):
        """Filter the CourseBot down by which user can access."""

        return self.filter(group__user__in=[user])

    def create_course_bot(self, name: str, context: str):
        """Create a Course Bot."""

        group = auth_models.Group.objects.create(name=f"{name}_students")
        inst = self.model(name=name, context=context, group=group)

        inst.full_clean()
        inst.save()

        return inst


class CourseBot(models.Model):
    """
    CourseBot.

    This model represents a configuration for a bot related to a course.
    """

    objects: CourseBotQuerySet = CourseBotQuerySet.as_manager()

    name = models.CharField(_("Name"), max_length=512, unique=True)
    """The Name of the Course."""

    context = models.TextField(_("Context"))
    """The Context used for the bot."""

    group = models.OneToOneField(
        auth_models.Group,
        on_delete=models.CASCADE,
        related_name="course_bot",
        verbose_name=_("Members"),
    )
    """The members of the course that can use the bot."""

    ## Relationships

    prompts: RelatedManager[Prompt]
    """The prompts submitted to the bot."""


### Prompt ###


class PromptQuerySet(models.QuerySet["Prompt"]):
    """Custom Queryset for Prompt."""

    def for_user(self, user: UserModel):
        """Filter the results by the user."""

        return self.filter(user=user)

    def for_bot(self, bot: CourseBot):
        """Filter the results by the bot."""

        return self.filter(bot=bot)

    def with_response(self):
        """Filter and annotate the prompt with its associated response."""

        return self.filter(response__isnull=False).prefetch_related("response")


class Prompt(models.Model):
    """
    Prompt.

    The prompt submitted by the user to a particular bot.
    """

    objects: PromptQuerySet = PromptQuerySet.as_manager()

    user = models.ForeignKey(
        UserModel, on_delete=models.DO_NOTHING, related_name="prompts"
    )
    """The user who submitted the prompt."""

    body = models.TextField(_("Prompt"))
    """The body of the prompt."""

    bot = models.ForeignKey(
        CourseBot, on_delete=models.DO_NOTHING, related_name="prompts"
    )
    """The bot the prompt was submitted to."""

    created_at = models.DateTimeField(auto_now_add=True)

    @property
    def response(self) -> Response | None:
        try:
            return self.response
        except Response.DoesNotExist:
            return None

    class Meta:
        ordering = ["-created_at"]


### Response ###


class ResponseQuerySet(models.QuerySet["Response"]):
    """Custom Queryset for Response."""

    def generate(self, bot: CourseBot, prompt: Prompt) -> t.Generator[str, None, None]:
        """Generate a response stream."""

        model = llm.get_model()
        history = list(
            itertools.chain(
                [
                    {"role": "user", "content": p.body},
                    {"role": "assistant", "content": p.response.body},
                ]
                for p in Prompt.objects.for_bot(bot)
                .for_user(prompt.user)
                .with_response()
            )
        )
        iterator = model.make_response(bot.context, history, prompt.body)

        response_data = []

        while True:
            try:
                line = next(iterator)
                response_data.append(line)
                yield line
            except StopIteration:
                break

        res = self.model(bot=bot, body="".join(response_data), prompt=prompt)
        res.save()


class Response(models.Model):
    """
    Response.

    The Response generated by the bot to a given prompt.
    """

    objects: ResponseQuerySet = ResponseQuerySet.as_manager()

    bot = models.ForeignKey(
        CourseBot, on_delete=models.DO_NOTHING, related_name="responses"
    )
    """The bot the response is generated by."""

    prompt = models.OneToOneField(
        Prompt, on_delete=models.DO_NOTHING, related_name="response"
    )
    """The prompt that is being responded to."""

    body = models.TextField(_("Response"))
    """The body of the response."""

    created_at = models.DateTimeField(auto_now_add=True)
